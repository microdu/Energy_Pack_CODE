// BA, MB , C2000 Systems and Applications
#include "HVPM_Sensorless_CLA-Shared_C.h"

#include "DSP2803x_EPwm.h"
#include "DSP2803x_Adc.h"
								
 
#define T		0.0001     			// ISR period

// Define the electrical motor parametes 

#define RS 		2.35		        // Stator resistance (ohm)  
#define LS   	0.0065    		  	// Stator inductance (H) 
#define POLES  	8					// Number of poles

// Define the base quantites for PU system conversion

#define BASE_VOLTAGE    236     	// Base peak phase voltage (volt)
#define BASE_CURRENT    10          // Base peak phase current (amp)
#define BASE_FREQ      	200         // Base electrical frequency (Hz) 
									
									
#define SpeedLoopPrescaler 10		// Speed PI presalar							

//Global Data used in Motor control software

// Variables used for computation on the CLA are in CLA writable space i.e. the CLA data RAM 

#pragma DATA_SECTION(rg1,"ClaDataRam0");
C28x_volatile RAMP_GEN_CLA rg1;  

#pragma DATA_SECTION(rc1,"ClaDataRam0");
C28x_volatile RAMP_CNTL_CLA rc1; 

#pragma DATA_SECTION(clarke1,"ClaDataRam0");
C28x_volatile CLARKE_CLA clarke1;

#pragma DATA_SECTION(park1,"ClaDataRam0");
C28x_volatile PARK_CLA park1;

#pragma DATA_SECTION(ipark1,"ClaDataRam0");
C28x_volatile iPARK_CLA ipark1;

#pragma DATA_SECTION(pwm1,"ClaDataRam0");
C28x_volatile PWMDRV_3phInv_CLA pwm1;

#pragma DATA_SECTION(pi_id,"ClaDataRam0");
#pragma DATA_SECTION(pi_iq,"ClaDataRam0");
#pragma DATA_SECTION(pi_spd,"ClaDataRam0");
C28x_volatile PI_CLA	pi_id,pi_iq,pi_spd;
				  
#pragma DATA_SECTION(svgen1,"ClaDataRam0");
C28x_volatile SVGEN_CLA svgen1;

#pragma DATA_SECTION(volt1,"ClaDataRam0");
C28x_volatile VOLT_CALC_CLA volt1;

#pragma DATA_SECTION(speed3,"ClaDataRam0");
C28x_volatile SPEED_ESTIMATION_CLA speed3;

#pragma DATA_SECTION(smo1,"ClaDataRam0");
C28x_volatile SMOPOS_CLA smo1;

#pragma DATA_SECTION(smo1_const,"ClaDataRam0");
C28x_volatile SMO_CONST_CLA smo1_const;				

#pragma DATA_SECTION(SpeedLoopCount,"ClaDataRam0");
volatile int SpeedLoopCount;

#pragma DATA_SECTION(IsrTicker,"ClaDataRam0");
volatile float IsrTicker;

#pragma DATA_SECTION(Cycles,"ClaDataRam0");
volatile float Cycles;

#pragma DATA_SECTION(Cycles_Avg,"ClaDataRam0");
volatile float Cycles_Avg;

#pragma DATA_SECTION(Cycles_Max,"ClaDataRam0");
volatile float Cycles_Max;

// The C28x instructs the CLA to change the speed or close speed loop
// These variables are declared in the message RAM 

#pragma DATA_SECTION(EnableFlag,"CpuToCla1MsgRAM");
volatile float EnableFlag;

#pragma DATA_SECTION(SpeedRef,"CpuToCla1MsgRAM");
volatile float SpeedRef;

#pragma DATA_SECTION(lsw,"CpuToCla1MsgRAM");
volatile int lsw;

#pragma DATA_SECTION(IdRef,"CpuToCla1MsgRAM");
volatile float IdRef;

#pragma DATA_SECTION(IqRef,"CpuToCla1MsgRAM");
volatile float IqRef;

#pragma DATA_SECTION(VdTesting,"CpuToCla1MsgRAM");
volatile float VdTesting;

#pragma DATA_SECTION(VqTesting,"CpuToCla1MsgRAM");
volatile float VqTesting;

// Whether MDEBUGSTOP needs to be compiled or not 
#define CLA_DEBUG 0

//Task 1
// Description: 
interrupt void Cla1Task1 ( void )
{
	#if (CLA_DEBUG==1)
	__mdebugstop();
	#endif
	
	EPwm5Regs.TBCTR=0;
	if(EnableFlag!=0)
	{
	IsrTicker++;
	// =============================== LEVEL 1 ======================================
	//	  Checks target independent modules, duty cycle waveforms and PWM update
	//	  Keep the motors disconnected at this level
	// ==============================================================================
	#if (DMC_CLA_BUILDLEVEL==LEVEL1)	 
	// ------------------------------------------------------------------------------
	//  Connect inputs of the RMP module and call the ramp control macro
	// ------------------------------------------------------------------------------
		rc1.TargetValue = SpeedRef;
		RAMP_CNTL_CLA_MACRO(rc1)
	
	// ------------------------------------------------------------------------------
	//  Connect inputs of the RAMP GEN module and call the ramp generator macro
	// ------------------------------------------------------------------------------
		rg1.Freq=rc1.SetpointValue;
		RAMP_GEN_CLA_MACRO(rg1)
	
	// ------------------------------------------------------------------------------
	//  Connect inputs of the INV_PARK module and call the inverse park trans. macro
	// ------------------------------------------------------------------------------
		ipark1.d=VdTesting;
		ipark1.q=VqTesting;
		ipark1.cos=CLAcosPU(rg1.Out);
		ipark1.sine=CLAsinPU(rg1.Out);
		iPARK_CLA_MACRO(ipark1)
	
	// ------------------------------------------------------------------------------
	//  Connect inputs of the SVGEN module and call the space-vector gen. macro
	// ------------------------------------------------------------------------------
		svgen1.Ualpha=ipark1.alpha;
		svgen1.Ubeta=ipark1.beta;
		SVGEN_CLA_MACRO(svgen1)
		
	// ------------------------------------------------------------------------------
	//  Connect inputs of the PWM_DRV module and call the PWM signal generation macro
	// ------------------------------------------------------------------------------
		pwm1.MfuncC1=svgen1.Ta;
		pwm1.MfuncC2=svgen1.Tb;
		pwm1.MfuncC3=svgen1.Tc;
		PWMDRV_3phInv_CLA_MACRO(pwm1)
		
	// ------------------------------------------------------------------------------
	//    Connect inputs of the PWMDAC module 
	// ------------------------------------------------------------------------------	
			
		PWMDRV_DAC_CLA_MACRO(park1.d,park1.q,park1.theta,clarke1.beta,500)
	
	#endif	
	
	// =============================== LEVEL 2 ======================================
	//	  Level 2 verifies the analog-to-digital conversion, offset compensation, 
	//    clarke/park transformations (CLARKE/PARK), phase voltage calculations 
	// ==============================================================================
	#if (DMC_CLA_BUILDLEVEL==LEVEL2)	 
	// ------------------------------------------------------------------------------
	//  Connect inputs of the RMP module and call the ramp control macro
	// ------------------------------------------------------------------------------
		rc1.TargetValue = SpeedRef;
		RAMP_CNTL_CLA_MACRO(rc1)
	
	// ------------------------------------------------------------------------------
	//  Connect inputs of the RAMP GEN module and call the ramp generator macro
	// ------------------------------------------------------------------------------
		rg1.Freq=rc1.SetpointValue;
		RAMP_GEN_CLA_MACRO(rg1)
	
	// ------------------------------------------------------------------------------
	//  Measure phase currents, subtract the offset and normalize from (-0.5,+0.5) to (-1,+1). 
	//	Connect inputs of the CLARKE module and call the clarke transformation macro
	// ------------------------------------------------------------------------------
		clarke1.As= ((AdcResult.ADCRESULT1*0.000244140625)-0.50)*2;// Phase A curr.
		clarke1.Bs= ((AdcResult.ADCRESULT2*0.000244140625)-0.50)*2;// Phase B curr.	
	
		CLARKE_CLA_MACRO(clarke1)
	// ------------------------------------------------------------------------------
	//  Connect inputs of the PARK module and call the park trans. macro
	// ------------------------------------------------------------------------------
		park1.theta = rg1.Out;
		park1.alpha=clarke1.alpha;
		park1.beta=clarke1.beta;
		
		PARK_CLA_MACRO(park1)
	// ------------------------------------------------------------------------------
	//  Connect inputs of the INV_PARK module and call the inverse park trans. macro
	// ------------------------------------------------------------------------------
		ipark1.d=VdTesting;
		ipark1.q=VqTesting;
		ipark1.cos=park1.cos;
		ipark1.sine=park1.sine;
		
		iPARK_CLA_MACRO(ipark1)
		
	// ------------------------------------------------------------------------------
	//  Connect inputs of the VOLT_CALC module and call the phase voltage calc. macro
	// ------------------------------------------------------------------------------
		volt1.DcBusVolt = ((float)AdcResult.ADCRESULT3)*0.000244140625;	// DC Bus voltage meas.
	    volt1.MfuncV1 = svgen1.Ta;
	    volt1.MfuncV2 = svgen1.Tb;
	    volt1.MfuncV3 = svgen1.Tc;
	    VOLT_CALC_CLA_MACRO(volt1) 
	    	
	// ------------------------------------------------------------------------------
	//  Connect inputs of the SVGEN module and call the space-vector gen. macro
	// ------------------------------------------------------------------------------
		svgen1.Ualpha=ipark1.alpha;
		svgen1.Ubeta=ipark1.beta;
		
		SVGEN_CLA_MACRO(svgen1)
	// ------------------------------------------------------------------------------
	//  Connect inputs of the PWM_DRV module and call the PWM signal generation macro
	// ------------------------------------------------------------------------------
		pwm1.MfuncC1=svgen1.Ta;
		pwm1.MfuncC2=svgen1.Tb;
		pwm1.MfuncC3=svgen1.Tc;
		
		PWMDRV_3phInv_CLA_MACRO(pwm1)
		
	// ------------------------------------------------------------------------------
	//    Connect inputs of the PWMDAC module 
	// ------------------------------------------------------------------------------
		PWMDRV_DAC_CLA_MACRO(park1.d,park1.q,park1.theta,clarke1.beta,500)
		
		
	#endif	
	
	// =============================== LEVEL 3 ======================================
	//	Level 3 verifies the dq-axis current regulation performed by PI and speed 
	//	measurement modules  
	// ==============================================================================  
	//  lsw=0: lock the rotor of the motor 
	//  lsw=1: close the current loop
	
	#if (DMC_CLA_BUILDLEVEL==LEVEL3)
	
	// ------------------------------------------------------------------------------
	//  Connect inputs of the RMP module and call the ramp control macro
	// ------------------------------------------------------------------------------
		if(lsw==0)rc1.TargetValue = 0;
		else rc1.TargetValue = SpeedRef;
		RAMP_CNTL_CLA_MACRO(rc1)
	
	// ------------------------------------------------------------------------------
	//  Connect inputs of the RAMP GEN module and call the ramp generator macro
	// ------------------------------------------------------------------------------
		rg1.Freq=rc1.SetpointValue;
		RAMP_GEN_CLA_MACRO(rg1)
	
	// ------------------------------------------------------------------------------
	//  Measure phase currents, subtract the offset and normalize from (-0.5,+0.5) to (-1,+1). 
	//	Connect inputs of the CLARKE module and call the clarke transformation macro
	// ------------------------------------------------------------------------------
		clarke1.As= ((AdcResult.ADCRESULT1*0.000244140625)-0.50)*2;// Phase A curr.
		clarke1.Bs= ((AdcResult.ADCRESULT2*0.000244140625)-0.50)*2;// Phase B curr.	
		CLARKE_CLA_MACRO(clarke1)
	
	// ------------------------------------------------------------------------------
	//  Connect inputs of the PARK module and call the park trans. macro
	// ------------------------------------------------------------------------------ 
		park1.alpha=clarke1.alpha;
		park1.beta=clarke1.beta;
		if (lsw==0) park1.theta = 0;
		else if (lsw==1) park1.theta = rg1.Out;
		
		park1.sine = CLAsinPU(park1.theta);
		park1.cos =  CLAcosPU(park1.theta);	
		
		PARK_CLA_MACRO(park1)
	
	// ------------------------------------------------------------------------------
	//  Connect inputs of the PI module and call the PI IQ controller macro
	// ------------------------------------------------------------------------------ 
		if (lsw==0)pi_iq.Ref=0;
		else if (lsw==1) pi_iq.Ref=IqRef;
		pi_iq.Fbk=park1.q;	
		PI_CLA_MACRO(pi_iq)
	
	// ------------------------------------------------------------------------------
	//  Connect inputs of the PI module and call the PI ID controller macro
	// ------------------------------------------------------------------------------
		if (lsw==0)pi_id.Ref= 0.05;
		else if (lsw==1)pi_id.Ref=IdRef;
		pi_id.Fbk=park1.d; 
		PI_CLA_MACRO(pi_id);
		
	// ------------------------------------------------------------------------------
	//	Connect inputs of the INV_PARK module and call the inverse park trans. macro
	// ------------------------------------------------------------------------------
		ipark1.d=pi_id.Out;
		ipark1.q=pi_iq.Out;
		ipark1.cos=park1.cos;
		ipark1.sine=park1.sine;
		iPARK_CLA_MACRO(ipark1)
		
	// ------------------------------------------------------------------------------
	//  Connect inputs of the VOLT_CALC module and call the phase voltage calc. macro
	// ------------------------------------------------------------------------------
		volt1.DcBusVolt = ((float)AdcResult.ADCRESULT3)*0.000244140625;	// DC Bus voltage meas.
	    volt1.MfuncV1 = svgen1.Ta;
	    volt1.MfuncV2 = svgen1.Tb;
	    volt1.MfuncV3 = svgen1.Tc;
	    VOLT_CALC_CLA_MACRO(volt1) 	
	
	// ------------------------------------------------------------------------------
	//  Connect inputs of the SVGEN module and call the space-vector gen. macro
	// ------------------------------------------------------------------------------
		svgen1.Ualpha=ipark1.alpha;
		svgen1.Ubeta=ipark1.beta;
		SVGEN_CLA_MACRO(svgen1)
		
	// ------------------------------------------------------------------------------
	//  Connect inputs of the PWM_DRV module and call the PWM signal generation macro
	// ------------------------------------------------------------------------------
		pwm1.MfuncC1=svgen1.Ta;
		pwm1.MfuncC2=svgen1.Tb;
		pwm1.MfuncC3=svgen1.Tc;
		PWMDRV_3phInv_CLA_MACRO(pwm1)
	
	// ------------------------------------------------------------------------------
	//    Connect inputs of the PWMDAC module 
	// ------------------------------------------------------------------------------	
		PWMDRV_DAC_CLA_MACRO(clarke1.As,rg1.Out,park1.q,ipark1.cos,500)
	
	#endif
	
	
	#if (DMC_CLA_BUILDLEVEL==LEVEL4)
	
	// =============================== LEVEL 4 ======================================
	//	  Level 4 verifies the estimated rotor position and speed estimation 
	//	  performed by SMOPOS and SPEED_EST modules, respectively. 
	// ==============================================================================  
	//  lsw=0: lock the rotor of the motor 
	//  lsw=1: close the current loop
	
	// ------------------------------------------------------------------------------
	//  Connect inputs of the RMP module and call the ramp control macro
	// ------------------------------------------------------------------------------
		if(lsw==0)rc1.TargetValue = 0;
		else rc1.TargetValue = SpeedRef;
		RAMP_CNTL_CLA_MACRO(rc1)
	
	// ------------------------------------------------------------------------------
	//  Connect inputs of the RAMP GEN module and call the ramp generator macro
	// ------------------------------------------------------------------------------
		rg1.Freq=rc1.SetpointValue;
		RAMP_GEN_CLA_MACRO(rg1)
	
	// ------------------------------------------------------------------------------
	//  Measure phase currents, subtract the offset and normalize from (-0.5,+0.5) to (-1,+1). 
	//	Connect inputs of the CLARKE module and call the clarke transformation macro
	// ------------------------------------------------------------------------------
		clarke1.As= ((AdcResult.ADCRESULT1*0.000244140625)-0.50)*2;// Phase A curr.
		clarke1.Bs= ((AdcResult.ADCRESULT2*0.000244140625)-0.50)*2;// Phase B curr.	
		CLARKE_CLA_MACRO(clarke1)
	
	// ------------------------------------------------------------------------------
	//  Connect inputs of the PARK module and call the park trans. macro
	// ------------------------------------------------------------------------------ 
		park1.alpha=clarke1.alpha;
		park1.beta=clarke1.beta;
		if (lsw==0) park1.theta = 0;
		else if (lsw==1) park1.theta = rg1.Out;
		
		park1.sine = CLAsinPU(park1.theta);
		park1.cos =  CLAcosPU(park1.theta);	
		
		PARK_CLA_MACRO(park1)
	
	// ------------------------------------------------------------------------------
	//  Connect inputs of the PI module and call the PI IQ controller macro
	// ------------------------------------------------------------------------------ 
		if (lsw==0)pi_iq.Ref=0;
		else if (lsw==1) pi_iq.Ref=IqRef;
		pi_iq.Fbk=park1.q;	
		PI_CLA_MACRO(pi_iq)
	
	// ------------------------------------------------------------------------------
	//  Connect inputs of the PI module and call the PI ID controller macro
	// ------------------------------------------------------------------------------
		if (lsw==0)pi_id.Ref= 0.05;
		else if (lsw==1)pi_id.Ref=IdRef;
		pi_id.Fbk=park1.d; 
		PI_CLA_MACRO(pi_id);
		
	// ------------------------------------------------------------------------------
	//	Connect inputs of the INV_PARK module and call the inverse park trans. macro
	// ------------------------------------------------------------------------------
		ipark1.d=pi_id.Out;
		ipark1.q=pi_iq.Out;
		ipark1.cos=park1.cos;
		ipark1.sine=park1.sine;
		iPARK_CLA_MACRO(ipark1)
	
	// ------------------------------------------------------------------------------
	//  Connect inputs of the VOLT_CALC module and call the phase voltage calc. macro
	// ------------------------------------------------------------------------------
		volt1.DcBusVolt = ((float)AdcResult.ADCRESULT3)*0.000244140625;	// DC Bus voltage meas.
	    volt1.MfuncV1 = svgen1.Ta;
	    volt1.MfuncV2 = svgen1.Tb;
	    volt1.MfuncV3 = svgen1.Tc;
	    VOLT_CALC_CLA_MACRO(volt1) 
	
	// ------------------------------------------------------------------------------
	//    Connect inputs of the SMO_POS module and call the sliding-mode observer macro
	// ------------------------------------------------------------------------------
	 	smo1.Ialpha = clarke1.alpha;
	  	smo1.Ibeta  = clarke1.beta;
	    smo1.Valpha = volt1.Valpha;
	    smo1.Vbeta  = volt1.Vbeta;
		SMOPOS_CLA_MACRO(smo1)
	
	// ------------------------------------------------------------------------------
	//    Connect inputs of the SPEED_EST module and call the estimated speed macro
	// ------------------------------------------------------------------------------
	    speed3.EstimatedTheta = smo1.Theta;
		SE_CLA_MACRO(speed3) 
		
	// ------------------------------------------------------------------------------
	//  Connect inputs of the SVGEN module and call the space-vector gen. macro
	// ------------------------------------------------------------------------------
		svgen1.Ualpha=ipark1.alpha;
		svgen1.Ubeta=ipark1.beta;
		SVGEN_CLA_MACRO(svgen1)
		
	// ------------------------------------------------------------------------------
	//  Connect inputs of the PWM_DRV module and call the PWM signal generation macro
	// ------------------------------------------------------------------------------
		pwm1.MfuncC1=svgen1.Ta;
		pwm1.MfuncC2=svgen1.Tb;
		pwm1.MfuncC3=svgen1.Tc;
		PWMDRV_3phInv_CLA_MACRO(pwm1)
	
	// ------------------------------------------------------------------------------
	//    Connect inputs of the PWMDAC module 
	// ------------------------------------------------------------------------------	
		
		PWMDRV_DAC_CLA_MACRO(smo1.Theta,smo1.Theta,smo1.Theta,volt1.Valpha ,500)
		
	#endif
	
	// =============================== LEVEL 5 ======================================
	//	  Level 6 verifies the speed regulator performed by PI module. 
	//	  The system speed loop is closed by using the estimated speed as a feedback.
	// ==============================================================================  
	//  lsw=0: lock the rotor of the motor
	//  lsw=1: close the current loop 
	//  lsw=2: close the speed loop
	
	#if (DMC_CLA_BUILDLEVEL==LEVEL5)
	
	// ------------------------------------------------------------------------------
	//  Connect inputs of the RMP module and call the ramp control macro
	// ------------------------------------------------------------------------------
		if(lsw==0)rc1.TargetValue = 0;
		else rc1.TargetValue = SpeedRef;
		RAMP_CNTL_CLA_MACRO(rc1)
	
	// ------------------------------------------------------------------------------
	//  Connect inputs of the RAMP GEN module and call the ramp generator macro
	// ------------------------------------------------------------------------------
		rg1.Freq=rc1.SetpointValue;
		RAMP_GEN_CLA_MACRO(rg1)
	
	// ------------------------------------------------------------------------------
	//  Measure phase currents, subtract the offset and normalize from (-0.5,+0.5) to (-1,+1). 
	//	Connect inputs of the CLARKE module and call the clarke transformation macro
	// ------------------------------------------------------------------------------
		clarke1.As= ((AdcResult.ADCRESULT1*0.000244140625)-0.50)*2;// Phase A curr.
		clarke1.Bs= ((AdcResult.ADCRESULT2*0.000244140625)-0.50)*2;// Phase B curr.	
		CLARKE_CLA_MACRO(clarke1)
	
	// ------------------------------------------------------------------------------
	//  Connect inputs of the PARK module and call the park trans. macro
	// ------------------------------------------------------------------------------ 
		if(lsw==0)	park1.theta = 0;
		else if(lsw==1)	park1.theta = rg1.Out;
		else park1.theta = smo1.Theta;
		park1.alpha=clarke1.alpha;
		park1.beta=clarke1.beta;
		park1.sine = CLAsinPU(park1.theta);
		park1.cos =  CLAcosPU(park1.theta);	
		
		PARK_CLA_MACRO(park1)
	
	// ------------------------------------------------------------------------------
	//  Connect inputs of the PI module and call the PI IQ controller macro
	// ------------------------------------------------------------------------------ 
		if (SpeedLoopCount==10)
		{
		pi_spd.Ref= rc1.SetpointValue ;
		pi_spd.Fbk= speed3.EstimatedSpeed;
		SpeedLoopCount=1;	
		PI_CLA_MACRO(pi_spd)
		}
		else 
		SpeedLoopCount++;  
		
		if(lsw==0 || lsw==1) { pi_spd.ui=0; pi_spd.i1=0;}
		
	// ------------------------------------------------------------------------------
	//  Connect inputs of the PI module and call the PI IQ controller macro
	// ------------------------------------------------------------------------------ 
		if(lsw==0) pi_iq.Ref = 0;
		else if (lsw==1) pi_iq.Ref = IqRef;
		else pi_iq.Ref = pi_spd.Out;
		pi_iq.Fbk=park1.q;
		PI_CLA_MACRO(pi_iq)
	
	// ------------------------------------------------------------------------------
	//  Connect inputs of the PI module and call the PI ID controller macro
	// ------------------------------------------------------------------------------
		if(lsw==0) pi_id.Ref = 0.05;
		else pi_id.Ref = 0;
		pi_id.Fbk=park1.d;
		PI_CLA_MACRO(pi_id)	
	
	// ------------------------------------------------------------------------------
	//	Connect inputs of the INV_PARK module and call the inverse park trans. macro
	// ------------------------------------------------------------------------------
		ipark1.d=pi_id.Out;
		ipark1.q=pi_iq.Out;
		ipark1.cos=park1.cos;
		ipark1.sine=park1.sine;
		
		iPARK_CLA_MACRO(ipark1)
	
	// ------------------------------------------------------------------------------
	//  Connect inputs of the VOLT_CALC module and call the phase voltage calc. macro
	// ------------------------------------------------------------------------------
		volt1.DcBusVolt = (AdcResult.ADCRESULT3)*0.000244140625;	// DC Bus voltage meas.
	    volt1.MfuncV1 = svgen1.Ta;
	    volt1.MfuncV2 = svgen1.Tb;
	    volt1.MfuncV3 = svgen1.Tc;
	    VOLT_CALC_CLA_MACRO(volt1) 
	// ------------------------------------------------------------------------------
	//    Connect inputs of the SMO_POS module and call the sliding-mode observer macro
	// ------------------------------------------------------------------------------
	 	if (lsw==2 && (smo1.Kslide<0.25)) smo1.Kslide=smo1.Kslide+0.00001; 
	 	
	 	smo1.Ialpha = clarke1.alpha;
	  	smo1.Ibeta  = clarke1.beta;
	    smo1.Valpha = volt1.Valpha;
	    smo1.Vbeta  = volt1.Vbeta;
		SMOPOS_CLA_MACRO(smo1)
	
	// ------------------------------------------------------------------------------
	//    Connect inputs of the SPEED_EST module and call the estimated speed macro
	// ------------------------------------------------------------------------------
	    speed3.EstimatedTheta = smo1.Theta;
		SE_CLA_MACRO(speed3) 
		
	// ------------------------------------------------------------------------------
	//  Connect inputs of the SVGEN module and call the space-vector gen. macro
	// ------------------------------------------------------------------------------
		svgen1.Ualpha=ipark1.alpha;
		svgen1.Ubeta=ipark1.beta;
		SVGEN_CLA_MACRO(svgen1)
		
	// ------------------------------------------------------------------------------
	//  Connect inputs of the PWM_DRV module and call the PWM signal generation macro
	// ------------------------------------------------------------------------------
		pwm1.MfuncC1=svgen1.Ta;
		pwm1.MfuncC2=svgen1.Tb;
		pwm1.MfuncC3=svgen1.Tc;
		PWMDRV_3phInv_CLA_MACRO(pwm1)
	
	// ------------------------------------------------------------------------------
	//    Connect inputs of the PWMDAC module 
	// ------------------------------------------------------------------------------	
		
		PWMDRV_DAC_CLA_MACRO(smo1.Theta,smo1.Theta,smo1.Theta,volt1.Valpha ,500)
		
	#endif
	}
	
	#if (CLA_DEBUG==1)
	__mdebugstop();
	#endif
	
}

interrupt void Cla1Task2 ( void )
{
	
}
interrupt void Cla1Task3 ( void )
{
	
}
interrupt void Cla1Task4 ( void )
{
	
}
interrupt void Cla1Task5 ( void )
{
	
}
interrupt void Cla1Task6 ( void )
{
	
}
interrupt void Cla1Task7 ( void )
{
	
}
interrupt void Cla1Task8 ( void )
{
	#if (CLA_DEBUG==1)
	__mdebugstop();
	#endif
	

	
// Keep your module initialization code that needs to be performed by the CLA here

	CLARKE_CLA_INIT(clarke1)
	PARK_CLA_INIT(park1)
	iPARK_CLA_INIT(ipark1)
	RAMP_CNTL_CLA_INIT(rc1)
	RAMP_GEN_CLA_INIT(rg1)
	PI_CLA_INIT(pi_id)
	PI_CLA_INIT(pi_iq)
	PI_CLA_INIT(pi_spd)
	VOLT_CALC_INIT_MACRO(volt1)
	SMO_CLA_INIT(smo1)
	SMO_CONST_INIT(smo1_const)
	SE_CLA_INIT(speed3)
	SVGEN_CLA_INIT_MACRO(svgen1)
	
// Initialize the PI module for Iq	
	pi_id.Kp=(1.0);
	pi_id.Ki=(T/0.04);
	pi_id.Umax =(0.3);
	pi_id.Umin =(-0.3);	
	
// Initialize the PI module for speed
	pi_iq.Kp=(1.0);
	pi_iq.Ki=(T/0.04);
	pi_iq.Umax =(0.8);
	pi_iq.Umin =(-0.8);

// Initialize the PI module for Id
    pi_spd.Kp=(1.5);
	pi_spd.Ki=(T*SpeedLoopPrescaler/0.2);
	pi_spd.Umax =(0.95);
	pi_spd.Umin =(-0.95);
	
// Initialize the phase voltage module
	volt1.OutOfPhase=1;

// Initialize the SPEED_EST module SMOPOS based speed calculation
    speed3.K1 = (1/(BASE_FREQ*T));
    speed3.K2 = (1/(1+T*2*3.14*5));  // Low-pass cut-off frequency 
    speed3.K3 =  1-speed3.K2;
    speed3.BaseRpm = 120*(BASE_FREQ/POLES);

// Initialize the SMOPOS constant module
	smo1_const.Rs = RS;
	smo1_const.Ls = LS;
	smo1_const.Ib = BASE_CURRENT;
	smo1_const.Vb = BASE_VOLTAGE;
	smo1_const.Ts = T;
	SMO_CONST_CLA_MACRO(smo1_const)

// Initialize the SMOPOS module
 	smo1.Fsmopos = smo1_const.Fsmopos;
 	smo1.Gsmopos = smo1_const.Gsmopos; 
 	smo1.Kslide =  0.05308703613;
    smo1.Kslf =    0.1057073975;
    
	SpeedLoopCount=0;
	pwm1.HalfPerMax=1500;
	IsrTicker=0;
	
	Cycles=0;
	Cycles_Avg=0;
	Cycles_Max=0;
	
	__mnop();
	__mnop();
	__mnop();
	
}
